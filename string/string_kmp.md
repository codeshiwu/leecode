### 1. 前言

​		KMP算法常用于字符串的比较。不使用KMP算法的前提下，我们通常会使用暴力解法来进行字符串的比较，但暴力解法的时间复杂度较高，而使用KMP算法会使比较的时间复杂度降低一个量级。

### 2. KMP算法介绍

#### 2.1 介绍

​		KMP算法的核心在于前缀表，即实现中常见的next数组。

​		解释next数组之前，还需要了解两个概念：前缀和后缀。**前缀**指的是以第一个字符开头但不包含最后一个字符的子字符串，**后缀**指的是以最后一个字符结束但不包含第一个字符的子字符串。具体实例如下：

```c++
str="aabaa";

// 其前缀有： a  aa  aab  aaba
// 其后缀有： a  aa  baa  abaa
```

​		next数组中的元素实际含义为：该字符串中最长相等前后缀的长度。`上述实例字符串中，最长相等前后缀的长度为2`。

​		KMP算法的精髓在于：比较文本串和模式串的过程中发现某个字符不同时，可以使用前缀表跳过模式串中已比较部分中相同的部分，具体实例如下：

```
文本串： "aabaabaafa"
模式串： "aabaaf"

字符串比较时,当index=5时字符不同，因前缀表的存在只需要模式串的索引退回2（即字符'b'）继续比较即可
<此例中最长相等前后缀为"aa",长度为2>
```

#### 2.2 next数组计算

​		next数组的长度与模式串的长度相等。`next[0]恒等于0`。

​		next数组计算的实际过程为：在原有最长相等前缀的基础上，比较其下一个字符和当前遍历字符是否相等，若相等则最长相等前缀长度+1，反之则需要回退。

具体做法如下：

```c++
int j = 0;     // 最长相等前缀的下一个元素
next[0] = j;
for (int i = 1; i < needle.size(); ++i) {
    while (j > 0 && needle[i] != needle[j] ) {
        j = next[j - 1];    // 回退
    }

    if (needle[i] == needle[j]) {
        j++;
    }

    next[i] = j;
}
```

​		**计算完成后，next数组中某索引  `i` 指向的元素值的实际含义为：索引为`0~i`的子串的最长相等前后缀的长度。**

#### 2.3 KMP算法比较

​		KMP算法比较的流程与next数组计算的流程类似：比较过程中某字符不一致，则根据前缀表进行回退，当模式串遍历结束时，则说明存在相同的子串；当文本串遍历完成但模式串未遍历完成，则说明不存在相同的子串。

```c++
int index = 0;
for (int i = 0; i < haystack.size(); ++i) {
	while (index > 0 && haystack[i] != needle[index]) {
		index = next[index - 1];
	}

    if (haystack[i] == needle[index]) {
        ++index;
    }

    if (index == needle.size()) {
        rst = i - index + 1;
        break;
    }
}
```

